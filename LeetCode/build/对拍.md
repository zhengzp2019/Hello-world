# 数据生成器&对拍

## 前言
> 最近在刷oj，遇到不会做的题，只有正确的源代码，但是找不到自己程序的问题，
>
>于是想到用确定正确的代码，跑出一组数据用来测试自己的程序，上网找了下资料,
>
>发现数据生成器和对拍技巧，花了一上午的时间终于搞明白了，在这里总结一下

*参考博客&推荐*
```
https://blog.csdn.net/qq_36294918/article/details/103041906
https://blog.csdn.net/C20190102/article/details/60138907
https://blog.csdn.net/C20190102/article/details/82944384#_141
```

## 什么是对拍
> 对拍就是将正确的程序跑出的数据在同样的输入文件下与自己的程序跑出的数进行
>
>比较。综上，对拍需要四个程序，数据生成器，对拍器，正确的程序，你的程序

## 一、数据生成器
> 生成数据，需要使用随机数生成函数rand( ),此处随机数并非真正的随机，而是用算法，以时间为输入值得到的0~Random_MAX区间内的随机整数(注：随机数还可以用来测试模板)
>
> 对于不同的程序需要不同的数据生成器，但对于不同的数据生成器，需要做如下三件事

``` Markdown
1.背住模板
2.写出能构造相应数据的代码
3.按题目格式输出
```

``` c++
#include<cstdio>
#include<ctime>//time函数的头文件
#include<cstdlib>//srand函数的头文件
int main()
{
    srand(time(NULL));//用于初始化随机数种子
    /*以下是你的构造方法*/
}
```

``` Markdown
**注：**
构造方法根据题目的格式编写对应的构造代码

**其他特殊**
>生成随机排列：先生成1~n，再random_shuffle()
>生成集合：用set
>生成无根树：随机生成一条树边，并查集检验连通性，合法的加入，不合法的忽略
>如果要限制每个结点的度，可加上deg[ ]数组，统计各点的度
>生成无向图：邻接矩阵存图，随机生成边，加在图上，做至少n*(n-1)/2次
>生成DAG：先生成无向图，再DFS，输出编号小的结点指向编号大的结点的边
```

``` c
**eg:**
for(int i = 1; i <= n; i++)
{
    sort(G[i].begin(), G[i].end());
    for(int j = 0; j < G[i].size(); j++)
    {
        int k = G[i][j];
        if(k > i)
            printf("%d %d\n", i, k);
    }
}
```
